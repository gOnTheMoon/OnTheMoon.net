<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>On the moon</title><link>http://onthemoon.net/</link><description>Recent content on On the moon</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 26 Sep 2020 18:48:45 -0400</lastBuildDate><atom:link href="http://onthemoon.net/index.xml" rel="self" type="application/rss+xml"/><item><title>6. StateDrivenEntity</title><link>http://onthemoon.net/post/2020-09-26/</link><pubDate>Sat, 26 Sep 2020 18:48:45 -0400</pubDate><guid>http://onthemoon.net/post/2020-09-26/</guid><description>Today we are going to talk about one of the most infamous mechanisms of the notification server: StateDrivenEntity.
Recall that every notification server can be thought of a gearbox, consisting of components which can be thought as the drive wheels. When our application launches, our notification server is at first not running. We need to perform some action in order to make it start, similarly to how we need to insert an ignition key and turn it in order to start a car engine.</description></item><item><title>5. Fractal processing server example - part 3</title><link>http://onthemoon.net/post/2020-08-29/</link><pubDate>Sat, 29 Aug 2020 20:47:05 -0400</pubDate><guid>http://onthemoon.net/post/2020-08-29/</guid><description>This is not really part 3, but a correction to the design of the fractal processing server sample. Currently, the design we use is the one in the following picture: I remind you that the component PixelStoreLogic receives events from the RequestListener and events from the ColorConvertLogic. The events from the RequestListener tell our logic to store the pixels received from the ColorConvertLogic. Once PixelStoreLogic receives all colored pixels of the image, it publishes an event containing all these pixels, and also cleans these events from its storage.</description></item><item><title>4. ComponentBuilder</title><link>http://onthemoon.net/post/2020-08-23/</link><pubDate>Sun, 23 Aug 2020 18:00:20 -0400</pubDate><guid>http://onthemoon.net/post/2020-08-23/</guid><description>Last time we saw how an implementation of a server over the notification server framework looks like. We discussed code of events, logics and rules. Something we have not discussed yet is how do we link components to one another. This is something that is resolved via a mechanism called component builder.
The component builder is an interface provided by the notification server framework, where one defines the components of a specific server and defines the links between these components.</description></item><item><title>3. Fractal processing server example - part 2</title><link>http://onthemoon.net/post/2020-08-16/</link><pubDate>Sun, 16 Aug 2020 17:37:56 -0400</pubDate><guid>http://onthemoon.net/post/2020-08-16/</guid><description>Today we are going to show a partial implementation of the fractal processing example we described last time. This should give a feeling of how typical code written above the notification server framework looks like.
We skip the RequestListener implementation for now. We will get to it in another time. What is important though is the event that the RequestListener produces. As explained in the first post, events are messages that flow through the server&amp;rsquo;s components.</description></item><item><title>2. Fractal processing server example - part 1</title><link>http://onthemoon.net/post/2020-07-15/</link><pubDate>Wed, 15 Jul 2020 20:37:55 -0400</pubDate><guid>http://onthemoon.net/post/2020-07-15/</guid><description>Today I want to discuss a simple example for a notification server, which is often given as a first exercise for developers new to the framework. This will be a variation of the usual exercise, so I can demonstrate some of the core concepts. The notification server we want to implement today is a server that generates pictures of fractals. For those of you who are not familiar with fractals, these are mathematical shapes with self-symmetry.</description></item><item><title>1. The notification server</title><link>http://onthemoon.net/post/2020-07-11/</link><pubDate>Sat, 11 Jul 2020 12:27:58 -0400</pubDate><guid>http://onthemoon.net/post/2020-07-11/</guid><description>So, we&amp;rsquo;re about to begin this journey. Before discussing how to implement a notification server, I should probably explain first what we are trying to build. That is what is a notification server?
Everyone has their own viewpoint on this, and here I will describe my own. A notification server is a box which consists of components which are linked to each other. It could be thought of as an engine, where each component is thought as a gear in the engine&amp;rsquo;s gearbox.</description></item><item><title>ConsoleHost.Run(args)</title><link>http://onthemoon.net/post/2020-07-08/</link><pubDate>Wed, 08 Jul 2020 22:58:34 -0400</pubDate><guid>http://onthemoon.net/post/2020-07-08/</guid><description>This blog is dedicated to the notification server project, a well established project which many have devoted their time to its development.
I decided to start this blog for two reasons. One is an educational reason: this blog should allow one to understand the underlying concepts of the notification server project, and ultimately will allow them to write their own implementation, with the perspectives and thoughts viewed in this blog in mind.</description></item></channel></rss>